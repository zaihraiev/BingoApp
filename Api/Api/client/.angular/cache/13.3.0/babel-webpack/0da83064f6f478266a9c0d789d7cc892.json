{"ast":null,"code":"import { Injectable, Directive, Optional, ChangeDetectorRef, ElementRef, Input, Pipe, NgModule } from '@angular/core';\nimport { of, timer, empty, Subject } from 'rxjs';\nimport { expand, skip, filter } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\n\nfunction coerceBooleanProperty(value) {\n  return value != null && `${value}` !== 'false';\n}\n\nfunction dateParser(date) {\n  const parsed = new Date(date);\n\n  if (!Number.isNaN(parsed.valueOf())) {\n    return parsed;\n  }\n\n  const parts = String(date).match(/\\d+/g);\n\n  if (parts === null || parts.length <= 2) {\n    return parsed;\n  } else {\n    const [firstP, secondP, ...restPs] = parts.map(x => parseInt(x, 10));\n    return new Date(Date.UTC(firstP, secondP - 1, ...restPs));\n  }\n}\n\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * 30;\nconst YEAR = DAY * 365;\n\nclass TimeagoClock {}\n\nlet TimeagoDefaultClock = /*#__PURE__*/(() => {\n  class TimeagoDefaultClock extends TimeagoClock {\n    tick(then) {\n      return of(0).pipe(expand(() => {\n        const now = Date.now();\n        const seconds = Math.round(Math.abs(now - then) / 1000);\n        const period = seconds < MINUTE ? 1000 : seconds < HOUR ? 1000 * MINUTE : seconds < DAY ? 1000 * HOUR : 0;\n        return period ? timer(period) : empty();\n      }), skip(1));\n    }\n\n  }\n\n  TimeagoDefaultClock.ɵfac = /*@__PURE__*/function () {\n    let ɵTimeagoDefaultClock_BaseFactory;\n    return function TimeagoDefaultClock_Factory(t) {\n      return (ɵTimeagoDefaultClock_BaseFactory || (ɵTimeagoDefaultClock_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimeagoDefaultClock)))(t || TimeagoDefaultClock);\n    };\n  }();\n\n  TimeagoDefaultClock.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimeagoDefaultClock,\n    factory: TimeagoDefaultClock.ɵfac\n  });\n  return TimeagoDefaultClock;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n;\n/**\n * To modify the text displayed, create a new instance of TimeagoIntl and\n * include it in a custom provider\n */\n\nlet TimeagoIntl = /*#__PURE__*/(() => {\n  class TimeagoIntl {\n    constructor() {\n      /**\n       * Stream that emits whenever the l10n strings are changed\n       * Use this to notify directives if the l10n strings have changed after initialization.\n       */\n      this.changes = new Subject();\n    }\n\n  }\n\n  TimeagoIntl.ɵfac = function TimeagoIntl_Factory(t) {\n    return new (t || TimeagoIntl)();\n  };\n\n  TimeagoIntl.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimeagoIntl,\n    factory: TimeagoIntl.ɵfac\n  });\n  return TimeagoIntl;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst defaultFormattter = function (then) {\n  const now = Date.now();\n  const seconds = Math.round(Math.abs(now - then) / 1000);\n  const suffix = then < now ? 'ago' : 'from now';\n  const [value, unit] = seconds < MINUTE ? [Math.round(seconds), 'second'] : seconds < HOUR ? [Math.round(seconds / MINUTE), 'minute'] : seconds < DAY ? [Math.round(seconds / HOUR), 'hour'] : seconds < WEEK ? [Math.round(seconds / DAY), 'day'] : seconds < MONTH ? [Math.round(seconds / WEEK), 'week'] : seconds < YEAR ? [Math.round(seconds / MONTH), 'month'] : [Math.round(seconds / YEAR), 'year'];\n  return {\n    value,\n    unit,\n    suffix\n  };\n};\n\nconst ɵ0 = defaultFormattter;\n\nclass TimeagoFormatter {}\n\nlet TimeagoDefaultFormatter = /*#__PURE__*/(() => {\n  class TimeagoDefaultFormatter extends TimeagoFormatter {\n    format(then) {\n      const {\n        suffix,\n        value,\n        unit\n      } = defaultFormattter(then);\n      return this.parse(value, unit, suffix);\n    }\n\n    parse(value, unit, suffix) {\n      if (value !== 1) {\n        unit += 's';\n      }\n\n      return value + ' ' + unit + ' ' + suffix;\n    }\n\n  }\n\n  TimeagoDefaultFormatter.ɵfac = /*@__PURE__*/function () {\n    let ɵTimeagoDefaultFormatter_BaseFactory;\n    return function TimeagoDefaultFormatter_Factory(t) {\n      return (ɵTimeagoDefaultFormatter_BaseFactory || (ɵTimeagoDefaultFormatter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimeagoDefaultFormatter)))(t || TimeagoDefaultFormatter);\n    };\n  }();\n\n  TimeagoDefaultFormatter.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimeagoDefaultFormatter,\n    factory: TimeagoDefaultFormatter.ɵfac\n  });\n  return TimeagoDefaultFormatter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TimeagoCustomFormatter = /*#__PURE__*/(() => {\n  class TimeagoCustomFormatter extends TimeagoFormatter {\n    constructor(intl) {\n      super();\n      this.intl = intl;\n    }\n\n    format(then) {\n      const {\n        suffix,\n        value,\n        unit\n      } = defaultFormattter(then);\n      return this.parse(value, unit, suffix, Date.now(), then);\n    }\n\n    parse(value, unit, suffix, now, then) {\n      /** convert weeks to days if strings don't handle weeks */\n      if (unit === 'week' && !this.intl.strings.week && !this.intl.strings.weeks) {\n        const days = Math.round(Math.abs(now - then) / (1000 * 60 * 60 * 24));\n        value = days;\n        unit = 'day';\n      }\n      /** create a normalize function for given value */\n\n\n      const normalize = this.normalizeFn(value, now - then, this.intl.strings.numbers);\n      /** The eventual return value stored in an array so that the wordSeparator can be used */\n\n      const dateString = [];\n      /** handle prefixes */\n\n      if (suffix === 'ago' && this.intl.strings.prefixAgo) {\n        dateString.push(normalize(this.intl.strings.prefixAgo));\n      }\n\n      if (suffix === 'from now' && this.intl.strings.prefixFromNow) {\n        dateString.push(normalize(this.intl.strings.prefixFromNow));\n      }\n      /** Handle Main number and unit */\n\n\n      const isPlural = value > 1;\n\n      if (isPlural) {\n        const stringFn = this.intl.strings[unit + 's'] || this.intl.strings[unit] || '%d ' + unit;\n        dateString.push(normalize(stringFn));\n      } else {\n        const stringFn = this.intl.strings[unit] || this.intl.strings[unit + 's'] || '%d ' + unit;\n        dateString.push(normalize(stringFn));\n      }\n      /** Handle Suffixes */\n\n\n      if (suffix === 'ago' && this.intl.strings.suffixAgo) {\n        dateString.push(normalize(this.intl.strings.suffixAgo));\n      }\n\n      if (suffix === 'from now' && this.intl.strings.suffixFromNow) {\n        dateString.push(normalize(this.intl.strings.suffixFromNow));\n      }\n      /** join the array into a string and return it */\n\n\n      const wordSeparator = typeof this.intl.strings.wordSeparator === 'string' ? this.intl.strings.wordSeparator : ' ';\n      return dateString.join(wordSeparator);\n    }\n    /**\n     * If the numbers array is present, format numbers with it,\n     * otherwise just cast the number to a string and return it\n    */\n\n\n    normalizeNumber(numbers, value) {\n      return numbers && numbers.length === 10 ? String(value).split('').map(digit => digit.match(/^[0-9]$/) ? numbers[parseInt(digit, 10)] : digit).join('') : String(value);\n    }\n    /**\n     * Take a string or a function that takes number of days and returns a string\n     * and provide a uniform API to create string parts\n    */\n\n\n    normalizeFn(value, millisDelta, numbers) {\n      return stringOrFn => typeof stringOrFn === 'function' ? stringOrFn(value, millisDelta).replace(/%d/g, this.normalizeNumber(numbers, value)) : stringOrFn.replace(/%d/g, this.normalizeNumber(numbers, value));\n    }\n\n  }\n\n  TimeagoCustomFormatter.ɵfac = function TimeagoCustomFormatter_Factory(t) {\n    return new (t || TimeagoCustomFormatter)(ɵngcc0.ɵɵinject(TimeagoIntl));\n  };\n\n  TimeagoCustomFormatter.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimeagoCustomFormatter,\n    factory: TimeagoCustomFormatter.ɵfac\n  });\n  return TimeagoCustomFormatter;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TimeagoDirective = /*#__PURE__*/(() => {\n  class TimeagoDirective {\n    constructor(intl, cd, formatter, element, clock) {\n      this.cd = cd;\n      this.clock = clock;\n      /**\n       * Emits on:\n       * - Input change\n       * - Intl change\n       * - Clock tick\n      */\n\n      this.stateChanges = new Subject();\n      this._live = true;\n\n      if (intl) {\n        this.intlSubscription = intl.changes.subscribe(() => this.stateChanges.next());\n      }\n\n      this.stateChanges.subscribe(() => {\n        this.setContent(element.nativeElement, formatter.format(this.date));\n        this.cd.markForCheck();\n      });\n    }\n    /** The Date to display. An actual Date object or something that can be fed to new Date. */\n\n\n    get date() {\n      return this._date;\n    }\n\n    set date(date) {\n      this._date = dateParser(date).valueOf();\n\n      if (this._date) {\n        if (this.clockSubscription) {\n          this.clockSubscription.unsubscribe();\n          this.clockSubscription = undefined;\n        }\n\n        this.clockSubscription = this.clock.tick(this.date).pipe(filter(() => this.live, this)).subscribe(() => this.stateChanges.next());\n      } else {\n        throw new SyntaxError(`Wrong parameter in TimeagoDirective. Expected a valid date, received: ${date}`);\n      }\n    }\n    /** If the directive should update itself over time */\n\n\n    get live() {\n      return this._live;\n    }\n\n    set live(live) {\n      this._live = coerceBooleanProperty(live);\n    }\n\n    ngOnChanges() {\n      this.stateChanges.next();\n    }\n\n    setContent(node, content) {\n      if (isDefined(node.textContent)) {\n        node.textContent = content;\n      } else {\n        node.data = content;\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n        this.intlSubscription = undefined;\n      }\n\n      if (this.clockSubscription) {\n        this.clockSubscription.unsubscribe();\n        this.clockSubscription = undefined;\n      }\n\n      this.stateChanges.complete();\n    }\n\n  }\n\n  TimeagoDirective.ɵfac = function TimeagoDirective_Factory(t) {\n    return new (t || TimeagoDirective)(ɵngcc0.ɵɵdirectiveInject(TimeagoIntl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(TimeagoFormatter), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TimeagoClock));\n  };\n\n  TimeagoDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TimeagoDirective,\n    selectors: [[\"\", \"timeago\", \"\"]],\n    inputs: {\n      date: \"date\",\n      live: \"live\"\n    },\n    exportAs: [\"timeago\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return TimeagoDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TimeagoPipe = /*#__PURE__*/(() => {\n  class TimeagoPipe {\n    constructor(intl, cd, formatter, clock) {\n      this.clock = clock;\n      this.live = true;\n      /**\n       * Emits on:\n       * - Input change\n       * - Intl change\n       * - Clock tick\n      */\n\n      this.stateChanges = new Subject();\n\n      if (intl) {\n        this.intlSubscription = intl.changes.subscribe(() => this.stateChanges.next());\n      }\n\n      this.stateChanges.subscribe(() => {\n        this.value = formatter.format(this.date);\n        cd.markForCheck();\n      });\n    }\n\n    transform(date, ...args) {\n      const _date = dateParser(date).valueOf();\n\n      let _live;\n\n      _live = isDefined(args[0]) ? coerceBooleanProperty(args[0]) : this.live;\n\n      if (this.date === _date && this.live === _live) {\n        return this.value;\n      }\n\n      this.date = _date;\n      this.live = _live;\n\n      if (this.date) {\n        if (this.clockSubscription) {\n          this.clockSubscription.unsubscribe();\n          this.clockSubscription = undefined;\n        }\n\n        this.clockSubscription = this.clock.tick(this.date).pipe(filter(() => this.live, this)).subscribe(() => this.stateChanges.next());\n        this.stateChanges.next();\n      } else {\n        throw new SyntaxError(`Wrong parameter in TimeagoPipe. Expected a valid date, received: ${date}`);\n      }\n\n      return this.value;\n    }\n\n    ngOnDestroy() {\n      if (this.intlSubscription) {\n        this.intlSubscription.unsubscribe();\n        this.intlSubscription = undefined;\n      }\n\n      if (this.clockSubscription) {\n        this.clockSubscription.unsubscribe();\n        this.clockSubscription = undefined;\n      }\n\n      this.stateChanges.complete();\n    }\n\n  }\n\n  TimeagoPipe.ɵfac = function TimeagoPipe_Factory(t) {\n    return new (t || TimeagoPipe)(ɵngcc0.ɵɵdirectiveInject(TimeagoIntl, 24), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef, 16), ɵngcc0.ɵɵdirectiveInject(TimeagoFormatter, 16), ɵngcc0.ɵɵdirectiveInject(TimeagoClock, 16));\n  };\n\n  TimeagoPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"timeago\",\n    type: TimeagoPipe,\n    pure: false\n  });\n  TimeagoPipe.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TimeagoPipe,\n    factory: TimeagoPipe.ɵfac\n  });\n  return TimeagoPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TimeagoModule = /*#__PURE__*/(() => {\n  class TimeagoModule {\n    /**\n     * Use this method in your root module to provide the TimeagoModule\n     */\n    static forRoot(config = {}) {\n      return {\n        ngModule: TimeagoModule,\n        providers: [config.clock || {\n          provide: TimeagoClock,\n          useClass: TimeagoDefaultClock\n        }, config.intl || [], config.formatter || {\n          provide: TimeagoFormatter,\n          useClass: TimeagoDefaultFormatter\n        }]\n      };\n    }\n    /**\n     * Use this method in your other (non root) modules to import the directive/pipe\n     */\n\n\n    static forChild(config = {}) {\n      return {\n        ngModule: TimeagoModule,\n        providers: [config.clock || {\n          provide: TimeagoClock,\n          useClass: TimeagoDefaultClock\n        }, config.intl || [], config.formatter || {\n          provide: TimeagoFormatter,\n          useClass: TimeagoDefaultFormatter\n        }]\n      };\n    }\n\n  }\n\n  TimeagoModule.ɵfac = function TimeagoModule_Factory(t) {\n    return new (t || TimeagoModule)();\n  };\n\n  TimeagoModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TimeagoModule\n  });\n  TimeagoModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return TimeagoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TimeagoModule, {\n    declarations: [TimeagoDirective, TimeagoPipe],\n    exports: [TimeagoDirective, TimeagoPipe]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TimeagoClock, TimeagoCustomFormatter, TimeagoDefaultClock, TimeagoDefaultFormatter, TimeagoDirective, TimeagoFormatter, TimeagoIntl, TimeagoModule, TimeagoPipe, ɵ0 }; //# sourceMappingURL=ngx-timeago.js.map","map":null,"metadata":{},"sourceType":"module"}