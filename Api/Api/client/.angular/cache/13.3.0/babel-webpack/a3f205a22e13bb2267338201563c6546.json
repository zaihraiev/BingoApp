{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { forwardRef, Directive, Input, HostBinding, HostListener, Optional, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms'; // TODO: config: activeClass - Class to apply to the checked buttons\n\nconst CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => ButtonCheckboxDirective),\n  multi: true\n};\n/**\n * Add checkbox functionality to any element\n */\n\nclass ButtonCheckboxDirective {\n  constructor() {\n    /** Truthy value, will be set to ngModel */\n    this.btnCheckboxTrue = true;\n    /** Falsy value, will be set to ngModel */\n\n    this.btnCheckboxFalse = false;\n    this.state = false;\n    this.isDisabled = false;\n    this.onChange = Function.prototype;\n    this.onTouched = Function.prototype;\n  } // view -> model\n\n\n  onClick() {\n    if (this.isDisabled) {\n      return;\n    }\n\n    this.toggle(!this.state);\n    this.onChange(this.value);\n  }\n\n  ngOnInit() {\n    this.toggle(this.trueValue === this.value);\n  }\n\n  get trueValue() {\n    return typeof this.btnCheckboxTrue !== 'undefined' ? this.btnCheckboxTrue : true;\n  }\n\n  get falseValue() {\n    return typeof this.btnCheckboxFalse !== 'undefined' ? this.btnCheckboxFalse : false;\n  }\n\n  toggle(state) {\n    this.state = state;\n    this.value = this.state ? this.trueValue : this.falseValue;\n  } // ControlValueAccessor\n  // model -> view\n\n\n  writeValue(value) {\n    this.state = this.trueValue === value;\n    this.value = value ? this.trueValue : this.falseValue;\n  }\n\n  setDisabledState(isDisabled) {\n    this.isDisabled = isDisabled;\n  }\n\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n\n}\n\nButtonCheckboxDirective.ɵfac = function ButtonCheckboxDirective_Factory(t) {\n  return new (t || ButtonCheckboxDirective)();\n};\n\nButtonCheckboxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ButtonCheckboxDirective,\n  selectors: [[\"\", \"btnCheckbox\", \"\"]],\n  hostVars: 3,\n  hostBindings: function ButtonCheckboxDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"click\", function ButtonCheckboxDirective_click_HostBindingHandler() {\n        return ctx.onClick();\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-pressed\", ctx.state);\n      i0.ɵɵclassProp(\"active\", ctx.state);\n    }\n  },\n  inputs: {\n    btnCheckboxTrue: \"btnCheckboxTrue\",\n    btnCheckboxFalse: \"btnCheckboxFalse\"\n  },\n  features: [i0.ɵɵProvidersFeature([CHECKBOX_CONTROL_VALUE_ACCESSOR])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ButtonCheckboxDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[btnCheckbox]',\n      providers: [CHECKBOX_CONTROL_VALUE_ACCESSOR]\n    }]\n  }], null, {\n    btnCheckboxTrue: [{\n      type: Input\n    }],\n    btnCheckboxFalse: [{\n      type: Input\n    }],\n    state: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: HostBinding,\n      args: ['attr.aria-pressed']\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click']\n    }]\n  });\n})();\n\nconst RADIO_CONTROL_VALUE_ACCESSOR$1 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => ButtonRadioDirective),\n  multi: true\n};\n/**\n * Create radio buttons or groups of buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\n\nclass ButtonRadioDirective {\n  constructor(el, cdr, renderer, group) {\n    this.el = el;\n    this.cdr = cdr;\n    this.renderer = renderer;\n    this.group = group;\n    this.onChange = Function.prototype;\n    this.onTouched = Function.prototype;\n    /** If `true` — radio button can be unchecked */\n\n    this.uncheckable = false;\n    this.role = 'radio';\n    this._disabled = false;\n    this._hasFocus = false;\n  }\n  /** Current value of radio component or group */\n\n\n  get value() {\n    return this.group ? this.group.value : this._value;\n  }\n\n  set value(value) {\n    if (this.group) {\n      this.group.value = value;\n      return;\n    }\n\n    this._value = value;\n\n    this._onChange(value);\n  }\n  /** If `true` — radio button is disabled */\n\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  set disabled(disabled) {\n    this.setDisabledState(disabled);\n  }\n\n  get controlOrGroupDisabled() {\n    return this.disabled || this.group && this.group.disabled ? true : undefined;\n  }\n\n  get hasDisabledClass() {\n    // Although the radio is disabled the active radio should still stand out.\n    // The disabled class will prevent this so don't add it on the active radio\n    return this.controlOrGroupDisabled && !this.isActive;\n  }\n\n  get isActive() {\n    return this.btnRadio === this.value;\n  }\n\n  get tabindex() {\n    if (this.controlOrGroupDisabled) {\n      // Disabled radio buttons should not receive focus\n      return undefined;\n    } else if (this.isActive || this.group == null) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  get hasFocus() {\n    return this._hasFocus;\n  }\n\n  toggleIfAllowed() {\n    if (!this.canToggle()) {\n      return;\n    }\n\n    if (this.uncheckable && this.btnRadio === this.value) {\n      this.value = undefined;\n    } else {\n      this.value = this.btnRadio;\n    }\n  }\n\n  onSpacePressed(event) {\n    this.toggleIfAllowed();\n    event.preventDefault();\n  }\n\n  focus() {\n    this.el.nativeElement.focus();\n  }\n\n  onFocus() {\n    this._hasFocus = true;\n  }\n\n  onBlur() {\n    this._hasFocus = false;\n    this.onTouched();\n  }\n\n  canToggle() {\n    return !this.controlOrGroupDisabled && (this.uncheckable || this.btnRadio !== this.value);\n  }\n\n  ngOnChanges(changes) {\n    if ('uncheckable' in changes) {\n      this.uncheckable = this.uncheckable !== false && typeof this.uncheckable !== 'undefined';\n    }\n  }\n\n  _onChange(value) {\n    if (this.group) {\n      this.group.value = value;\n      return;\n    }\n\n    this.onTouched();\n    this.onChange(value);\n  } // ControlValueAccessor\n  // model -> view\n\n\n  writeValue(value) {\n    this.value = value;\n    this.cdr.markForCheck();\n  }\n\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(disabled) {\n    this._disabled = disabled;\n\n    if (disabled) {\n      this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');\n      return;\n    }\n\n    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n  }\n\n}\n\nButtonRadioDirective.ɵfac = function ButtonRadioDirective_Factory(t) {\n  return new (t || ButtonRadioDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(forwardRef(() => ButtonRadioGroupDirective), 8));\n};\n\nButtonRadioDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ButtonRadioDirective,\n  selectors: [[\"\", \"btnRadio\", \"\"]],\n  hostVars: 8,\n  hostBindings: function ButtonRadioDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"click\", function ButtonRadioDirective_click_HostBindingHandler() {\n        return ctx.toggleIfAllowed();\n      })(\"keydown.space\", function ButtonRadioDirective_keydown_space_HostBindingHandler($event) {\n        return ctx.onSpacePressed($event);\n      })(\"focus\", function ButtonRadioDirective_focus_HostBindingHandler() {\n        return ctx.onFocus();\n      })(\"blur\", function ButtonRadioDirective_blur_HostBindingHandler() {\n        return ctx.onBlur();\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-disabled\", ctx.controlOrGroupDisabled)(\"aria-checked\", ctx.isActive)(\"role\", ctx.role)(\"tabindex\", ctx.tabindex);\n      i0.ɵɵclassProp(\"disabled\", ctx.hasDisabledClass)(\"active\", ctx.isActive);\n    }\n  },\n  inputs: {\n    btnRadio: \"btnRadio\",\n    uncheckable: \"uncheckable\",\n    value: \"value\",\n    disabled: \"disabled\"\n  },\n  features: [i0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR$1]), i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ButtonRadioDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[btnRadio]',\n      providers: [RADIO_CONTROL_VALUE_ACCESSOR$1]\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: ButtonRadioGroupDirective,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [forwardRef(() => ButtonRadioGroupDirective)]\n      }]\n    }];\n  }, {\n    btnRadio: [{\n      type: Input\n    }],\n    uncheckable: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    controlOrGroupDisabled: [{\n      type: HostBinding,\n      args: ['attr.aria-disabled']\n    }],\n    hasDisabledClass: [{\n      type: HostBinding,\n      args: ['class.disabled']\n    }],\n    isActive: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: HostBinding,\n      args: ['attr.aria-checked']\n    }],\n    role: [{\n      type: HostBinding,\n      args: ['attr.role']\n    }],\n    tabindex: [{\n      type: HostBinding,\n      args: ['attr.tabindex']\n    }],\n    toggleIfAllowed: [{\n      type: HostListener,\n      args: ['click']\n    }],\n    onSpacePressed: [{\n      type: HostListener,\n      args: ['keydown.space', ['$event']]\n    }],\n    onFocus: [{\n      type: HostListener,\n      args: ['focus']\n    }],\n    onBlur: [{\n      type: HostListener,\n      args: ['blur']\n    }]\n  });\n})();\n\nconst RADIO_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => ButtonRadioGroupDirective),\n  multi: true\n};\n/**\n * A group of radio buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\n\nclass ButtonRadioGroupDirective {\n  constructor(cdr) {\n    this.cdr = cdr;\n    this.onChange = Function.prototype;\n    this.onTouched = Function.prototype;\n    this.role = 'radiogroup';\n    this._disabled = false;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this._value = value;\n    this.onChange(value);\n  }\n\n  get disabled() {\n    return this._disabled;\n  }\n\n  get tabindex() {\n    if (this._disabled) {\n      return null;\n    } else {\n      return 0;\n    }\n  }\n\n  writeValue(value) {\n    this._value = value;\n    this.cdr.markForCheck();\n  }\n\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(disabled) {\n    if (this.radioButtons) {\n      this._disabled = disabled;\n      this.radioButtons.forEach(buttons => {\n        buttons.setDisabledState(disabled);\n      });\n      this.cdr.markForCheck();\n    }\n  }\n\n  onFocus() {\n    if (this._disabled) {\n      return;\n    }\n\n    const activeRadio = this.getActiveOrFocusedRadio();\n\n    if (activeRadio) {\n      activeRadio.focus();\n      return;\n    }\n\n    if (this.radioButtons) {\n      const firstEnabled = this.radioButtons.find(r => !r.disabled);\n\n      if (firstEnabled) {\n        firstEnabled.focus();\n      }\n    }\n  }\n\n  onBlur() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  selectNext(event) {\n    this.selectInDirection('next');\n    event.preventDefault();\n  }\n\n  selectPrevious(event) {\n    this.selectInDirection('previous');\n    event.preventDefault();\n  }\n\n  selectInDirection(direction) {\n    if (this._disabled) {\n      return;\n    }\n\n    function nextIndex(currentIndex, buttonRadioDirectives) {\n      const step = direction === 'next' ? 1 : -1;\n      let calcIndex = (currentIndex + step) % buttonRadioDirectives.length;\n\n      if (calcIndex < 0) {\n        calcIndex = buttonRadioDirectives.length - 1;\n      }\n\n      return calcIndex;\n    }\n\n    const activeRadio = this.getActiveOrFocusedRadio();\n\n    if (activeRadio && this.radioButtons) {\n      const buttonRadioDirectives = this.radioButtons.toArray();\n      const currentActiveIndex = buttonRadioDirectives.indexOf(activeRadio);\n\n      for (let i = nextIndex(currentActiveIndex, buttonRadioDirectives); i !== currentActiveIndex; i = nextIndex(i, buttonRadioDirectives)) {\n        if (buttonRadioDirectives[i].canToggle()) {\n          buttonRadioDirectives[i].toggleIfAllowed();\n          buttonRadioDirectives[i].focus();\n          break;\n        }\n      }\n    }\n  }\n\n  getActiveOrFocusedRadio() {\n    if (!this.radioButtons) {\n      return void 0;\n    }\n\n    return this.radioButtons.find(button => button.isActive) || this.radioButtons.find(button => button.hasFocus);\n  }\n\n}\n\nButtonRadioGroupDirective.ɵfac = function ButtonRadioGroupDirective_Factory(t) {\n  return new (t || ButtonRadioGroupDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n};\n\nButtonRadioGroupDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ButtonRadioGroupDirective,\n  selectors: [[\"\", \"btnRadioGroup\", \"\"]],\n  contentQueries: function ButtonRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, ButtonRadioDirective, 4);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.radioButtons = _t);\n    }\n  },\n  hostVars: 2,\n  hostBindings: function ButtonRadioGroupDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"focus\", function ButtonRadioGroupDirective_focus_HostBindingHandler() {\n        return ctx.onFocus();\n      })(\"blur\", function ButtonRadioGroupDirective_blur_HostBindingHandler() {\n        return ctx.onBlur();\n      })(\"keydown.ArrowRight\", function ButtonRadioGroupDirective_keydown_ArrowRight_HostBindingHandler($event) {\n        return ctx.selectNext($event);\n      })(\"keydown.ArrowDown\", function ButtonRadioGroupDirective_keydown_ArrowDown_HostBindingHandler($event) {\n        return ctx.selectNext($event);\n      })(\"keydown.ArrowLeft\", function ButtonRadioGroupDirective_keydown_ArrowLeft_HostBindingHandler($event) {\n        return ctx.selectPrevious($event);\n      })(\"keydown.ArrowUp\", function ButtonRadioGroupDirective_keydown_ArrowUp_HostBindingHandler($event) {\n        return ctx.selectPrevious($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex);\n    }\n  },\n  features: [i0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ButtonRadioGroupDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[btnRadioGroup]',\n      providers: [RADIO_CONTROL_VALUE_ACCESSOR]\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }];\n  }, {\n    role: [{\n      type: HostBinding,\n      args: ['attr.role']\n    }],\n    radioButtons: [{\n      type: ContentChildren,\n      args: [forwardRef(() => ButtonRadioDirective)]\n    }],\n    tabindex: [{\n      type: HostBinding,\n      args: ['attr.tabindex']\n    }],\n    onFocus: [{\n      type: HostListener,\n      args: ['focus']\n    }],\n    onBlur: [{\n      type: HostListener,\n      args: ['blur']\n    }],\n    selectNext: [{\n      type: HostListener,\n      args: ['keydown.ArrowRight', ['$event']]\n    }, {\n      type: HostListener,\n      args: ['keydown.ArrowDown', ['$event']]\n    }],\n    selectPrevious: [{\n      type: HostListener,\n      args: ['keydown.ArrowLeft', ['$event']]\n    }, {\n      type: HostListener,\n      args: ['keydown.ArrowUp', ['$event']]\n    }]\n  });\n})();\n\nclass ButtonsModule {\n  static forRoot() {\n    return {\n      ngModule: ButtonsModule,\n      providers: []\n    };\n  }\n\n}\n\nButtonsModule.ɵfac = function ButtonsModule_Factory(t) {\n  return new (t || ButtonsModule)();\n};\n\nButtonsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: ButtonsModule\n});\nButtonsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ButtonsModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective],\n      exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective, ButtonsModule };","map":{"version":3,"sources":["C:/Users/Acer/Desktop/Angular/client/node_modules/ngx-bootstrap/buttons/fesm2015/ngx-bootstrap-buttons.mjs"],"names":["i0","forwardRef","Directive","Input","HostBinding","HostListener","Optional","Inject","ContentChildren","NgModule","NG_VALUE_ACCESSOR","CHECKBOX_CONTROL_VALUE_ACCESSOR","provide","useExisting","ButtonCheckboxDirective","multi","constructor","btnCheckboxTrue","btnCheckboxFalse","state","isDisabled","onChange","Function","prototype","onTouched","onClick","toggle","value","ngOnInit","trueValue","falseValue","writeValue","setDisabledState","registerOnChange","fn","registerOnTouched","ɵfac","ɵdir","type","args","selector","providers","RADIO_CONTROL_VALUE_ACCESSOR$1","ButtonRadioDirective","el","cdr","renderer","group","uncheckable","role","_disabled","_hasFocus","_value","_onChange","disabled","controlOrGroupDisabled","undefined","hasDisabledClass","isActive","btnRadio","tabindex","hasFocus","toggleIfAllowed","canToggle","onSpacePressed","event","preventDefault","focus","nativeElement","onFocus","onBlur","ngOnChanges","changes","markForCheck","setAttribute","removeAttribute","ElementRef","ChangeDetectorRef","Renderer2","ButtonRadioGroupDirective","decorators","RADIO_CONTROL_VALUE_ACCESSOR","radioButtons","forEach","buttons","activeRadio","getActiveOrFocusedRadio","firstEnabled","find","r","selectNext","selectInDirection","selectPrevious","direction","nextIndex","currentIndex","buttonRadioDirectives","step","calcIndex","length","toArray","currentActiveIndex","indexOf","i","button","ButtonsModule","forRoot","ngModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { forwardRef, Directive, Input, HostBinding, HostListener, Optional, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n\n// TODO: config: activeClass - Class to apply to the checked buttons\nconst CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => ButtonCheckboxDirective),\n    multi: true\n};\n/**\n * Add checkbox functionality to any element\n */\nclass ButtonCheckboxDirective {\n    constructor() {\n        /** Truthy value, will be set to ngModel */\n        this.btnCheckboxTrue = true;\n        /** Falsy value, will be set to ngModel */\n        this.btnCheckboxFalse = false;\n        this.state = false;\n        this.isDisabled = false;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n    }\n    // view -> model\n    onClick() {\n        if (this.isDisabled) {\n            return;\n        }\n        this.toggle(!this.state);\n        this.onChange(this.value);\n    }\n    ngOnInit() {\n        this.toggle(this.trueValue === this.value);\n    }\n    get trueValue() {\n        return typeof this.btnCheckboxTrue !== 'undefined'\n            ? this.btnCheckboxTrue\n            : true;\n    }\n    get falseValue() {\n        return typeof this.btnCheckboxFalse !== 'undefined'\n            ? this.btnCheckboxFalse\n            : false;\n    }\n    toggle(state) {\n        this.state = state;\n        this.value = this.state ? this.trueValue : this.falseValue;\n    }\n    // ControlValueAccessor\n    // model -> view\n    writeValue(value) {\n        this.state = this.trueValue === value;\n        this.value = value ? this.trueValue : this.falseValue;\n    }\n    setDisabledState(isDisabled) {\n        this.isDisabled = isDisabled;\n    }\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n}\nButtonCheckboxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonCheckboxDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nButtonCheckboxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.1\", type: ButtonCheckboxDirective, selector: \"[btnCheckbox]\", inputs: { btnCheckboxTrue: \"btnCheckboxTrue\", btnCheckboxFalse: \"btnCheckboxFalse\" }, host: { listeners: { \"click\": \"onClick()\" }, properties: { \"class.active\": \"this.state\", \"attr.aria-pressed\": \"this.state\" } }, providers: [CHECKBOX_CONTROL_VALUE_ACCESSOR], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonCheckboxDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[btnCheckbox]',\n                    providers: [CHECKBOX_CONTROL_VALUE_ACCESSOR]\n                }]\n        }], propDecorators: { btnCheckboxTrue: [{\n                type: Input\n            }], btnCheckboxFalse: [{\n                type: Input\n            }], state: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: HostBinding,\n                args: ['attr.aria-pressed']\n            }], onClick: [{\n                type: HostListener,\n                args: ['click']\n            }] } });\n\nconst RADIO_CONTROL_VALUE_ACCESSOR$1 = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => ButtonRadioDirective),\n    multi: true\n};\n/**\n * Create radio buttons or groups of buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\nclass ButtonRadioDirective {\n    constructor(el, cdr, renderer, group) {\n        this.el = el;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        this.group = group;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n        /** If `true` — radio button can be unchecked */\n        this.uncheckable = false;\n        this.role = 'radio';\n        this._disabled = false;\n        this._hasFocus = false;\n    }\n    /** Current value of radio component or group */\n    get value() {\n        return this.group ? this.group.value : this._value;\n    }\n    set value(value) {\n        if (this.group) {\n            this.group.value = value;\n            return;\n        }\n        this._value = value;\n        this._onChange(value);\n    }\n    /** If `true` — radio button is disabled */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(disabled) {\n        this.setDisabledState(disabled);\n    }\n    get controlOrGroupDisabled() {\n        return this.disabled || (this.group && this.group.disabled) ? true : undefined;\n    }\n    get hasDisabledClass() {\n        // Although the radio is disabled the active radio should still stand out.\n        // The disabled class will prevent this so don't add it on the active radio\n        return this.controlOrGroupDisabled && !this.isActive;\n    }\n    get isActive() {\n        return this.btnRadio === this.value;\n    }\n    get tabindex() {\n        if (this.controlOrGroupDisabled) {\n            // Disabled radio buttons should not receive focus\n            return undefined;\n        }\n        else if (this.isActive || this.group == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    get hasFocus() {\n        return this._hasFocus;\n    }\n    toggleIfAllowed() {\n        if (!this.canToggle()) {\n            return;\n        }\n        if (this.uncheckable && this.btnRadio === this.value) {\n            this.value = undefined;\n        }\n        else {\n            this.value = this.btnRadio;\n        }\n    }\n    onSpacePressed(event) {\n        this.toggleIfAllowed();\n        event.preventDefault();\n    }\n    focus() {\n        this.el.nativeElement.focus();\n    }\n    onFocus() {\n        this._hasFocus = true;\n    }\n    onBlur() {\n        this._hasFocus = false;\n        this.onTouched();\n    }\n    canToggle() {\n        return !this.controlOrGroupDisabled && (this.uncheckable || this.btnRadio !== this.value);\n    }\n    ngOnChanges(changes) {\n        if ('uncheckable' in changes) {\n            this.uncheckable = this.uncheckable !== false && typeof this.uncheckable !== 'undefined';\n        }\n    }\n    _onChange(value) {\n        if (this.group) {\n            this.group.value = value;\n            return;\n        }\n        this.onTouched();\n        this.onChange(value);\n    }\n    // ControlValueAccessor\n    // model -> view\n    writeValue(value) {\n        this.value = value;\n        this.cdr.markForCheck();\n    }\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    setDisabledState(disabled) {\n        this._disabled = disabled;\n        if (disabled) {\n            this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');\n            return;\n        }\n        this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n}\nButtonRadioDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonRadioDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: forwardRef(() => ButtonRadioGroupDirective), optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nButtonRadioDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.1\", type: ButtonRadioDirective, selector: \"[btnRadio]\", inputs: { btnRadio: \"btnRadio\", uncheckable: \"uncheckable\", value: \"value\", disabled: \"disabled\" }, host: { listeners: { \"click\": \"toggleIfAllowed()\", \"keydown.space\": \"onSpacePressed($event)\", \"focus\": \"onFocus()\", \"blur\": \"onBlur()\" }, properties: { \"attr.aria-disabled\": \"this.controlOrGroupDisabled\", \"class.disabled\": \"this.hasDisabledClass\", \"class.active\": \"this.isActive\", \"attr.aria-checked\": \"this.isActive\", \"attr.role\": \"this.role\", \"attr.tabindex\": \"this.tabindex\" } }, providers: [RADIO_CONTROL_VALUE_ACCESSOR$1], usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonRadioDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[btnRadio]',\n                    providers: [RADIO_CONTROL_VALUE_ACCESSOR$1]\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: ButtonRadioGroupDirective, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [forwardRef(() => ButtonRadioGroupDirective)]\n                    }] }];\n    }, propDecorators: { btnRadio: [{\n                type: Input\n            }], uncheckable: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }], controlOrGroupDisabled: [{\n                type: HostBinding,\n                args: ['attr.aria-disabled']\n            }], hasDisabledClass: [{\n                type: HostBinding,\n                args: ['class.disabled']\n            }], isActive: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: HostBinding,\n                args: ['attr.aria-checked']\n            }], role: [{\n                type: HostBinding,\n                args: ['attr.role']\n            }], tabindex: [{\n                type: HostBinding,\n                args: ['attr.tabindex']\n            }], toggleIfAllowed: [{\n                type: HostListener,\n                args: ['click']\n            }], onSpacePressed: [{\n                type: HostListener,\n                args: ['keydown.space', ['$event']]\n            }], onFocus: [{\n                type: HostListener,\n                args: ['focus']\n            }], onBlur: [{\n                type: HostListener,\n                args: ['blur']\n            }] } });\n\nconst RADIO_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => ButtonRadioGroupDirective),\n    multi: true\n};\n/**\n * A group of radio buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\nclass ButtonRadioGroupDirective {\n    constructor(cdr) {\n        this.cdr = cdr;\n        this.onChange = Function.prototype;\n        this.onTouched = Function.prototype;\n        this.role = 'radiogroup';\n        this._disabled = false;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n        this.onChange(value);\n    }\n    get disabled() {\n        return this._disabled;\n    }\n    get tabindex() {\n        if (this._disabled) {\n            return null;\n        }\n        else {\n            return 0;\n        }\n    }\n    writeValue(value) {\n        this._value = value;\n        this.cdr.markForCheck();\n    }\n    registerOnChange(fn) {\n        this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onTouched = fn;\n    }\n    setDisabledState(disabled) {\n        if (this.radioButtons) {\n            this._disabled = disabled;\n            this.radioButtons.forEach(buttons => {\n                buttons.setDisabledState(disabled);\n            });\n            this.cdr.markForCheck();\n        }\n    }\n    onFocus() {\n        if (this._disabled) {\n            return;\n        }\n        const activeRadio = this.getActiveOrFocusedRadio();\n        if (activeRadio) {\n            activeRadio.focus();\n            return;\n        }\n        if (this.radioButtons) {\n            const firstEnabled = this.radioButtons.find(r => !r.disabled);\n            if (firstEnabled) {\n                firstEnabled.focus();\n            }\n        }\n    }\n    onBlur() {\n        if (this.onTouched) {\n            this.onTouched();\n        }\n    }\n    selectNext(event) {\n        this.selectInDirection('next');\n        event.preventDefault();\n    }\n    selectPrevious(event) {\n        this.selectInDirection('previous');\n        event.preventDefault();\n    }\n    selectInDirection(direction) {\n        if (this._disabled) {\n            return;\n        }\n        function nextIndex(currentIndex, buttonRadioDirectives) {\n            const step = direction === 'next' ? 1 : -1;\n            let calcIndex = (currentIndex + step) % buttonRadioDirectives.length;\n            if (calcIndex < 0) {\n                calcIndex = buttonRadioDirectives.length - 1;\n            }\n            return calcIndex;\n        }\n        const activeRadio = this.getActiveOrFocusedRadio();\n        if (activeRadio && this.radioButtons) {\n            const buttonRadioDirectives = this.radioButtons.toArray();\n            const currentActiveIndex = buttonRadioDirectives.indexOf(activeRadio);\n            for (let i = nextIndex(currentActiveIndex, buttonRadioDirectives); i !== currentActiveIndex; i = nextIndex(i, buttonRadioDirectives)) {\n                if (buttonRadioDirectives[i].canToggle()) {\n                    buttonRadioDirectives[i].toggleIfAllowed();\n                    buttonRadioDirectives[i].focus();\n                    break;\n                }\n            }\n        }\n    }\n    getActiveOrFocusedRadio() {\n        if (!this.radioButtons) {\n            return void 0;\n        }\n        return this.radioButtons.find(button => button.isActive)\n            || this.radioButtons.find(button => button.hasFocus);\n    }\n}\nButtonRadioGroupDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonRadioGroupDirective, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\nButtonRadioGroupDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.1\", type: ButtonRadioGroupDirective, selector: \"[btnRadioGroup]\", host: { listeners: { \"focus\": \"onFocus()\", \"blur\": \"onBlur()\", \"keydown.ArrowRight\": \"selectNext($event)\", \"keydown.ArrowDown\": \"selectNext($event)\", \"keydown.ArrowLeft\": \"selectPrevious($event)\", \"keydown.ArrowUp\": \"selectPrevious($event)\" }, properties: { \"attr.role\": \"this.role\", \"attr.tabindex\": \"this.tabindex\" } }, providers: [RADIO_CONTROL_VALUE_ACCESSOR], queries: [{ propertyName: \"radioButtons\", predicate: i0.forwardRef(function () { return ButtonRadioDirective; }) }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonRadioGroupDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[btnRadioGroup]',\n                    providers: [RADIO_CONTROL_VALUE_ACCESSOR]\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { role: [{\n                type: HostBinding,\n                args: ['attr.role']\n            }], radioButtons: [{\n                type: ContentChildren,\n                args: [forwardRef(() => ButtonRadioDirective)]\n            }], tabindex: [{\n                type: HostBinding,\n                args: ['attr.tabindex']\n            }], onFocus: [{\n                type: HostListener,\n                args: ['focus']\n            }], onBlur: [{\n                type: HostListener,\n                args: ['blur']\n            }], selectNext: [{\n                type: HostListener,\n                args: ['keydown.ArrowRight', ['$event']]\n            }, {\n                type: HostListener,\n                args: ['keydown.ArrowDown', ['$event']]\n            }], selectPrevious: [{\n                type: HostListener,\n                args: ['keydown.ArrowLeft', ['$event']]\n            }, {\n                type: HostListener,\n                args: ['keydown.ArrowUp', ['$event']]\n            }] } });\n\nclass ButtonsModule {\n    static forRoot() {\n        return { ngModule: ButtonsModule, providers: [] };\n    }\n}\nButtonsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nButtonsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonsModule, declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective], exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective] });\nButtonsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: ButtonsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective],\n                    exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective, ButtonsModule };\n"]},"metadata":{},"sourceType":"module"}